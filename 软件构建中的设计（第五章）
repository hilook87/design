设计是一项明确的活动

设计是一个险恶的问题
|
“险恶的”问题就是那种只有通过解决或部分解决才能被明确的问题；
最引人注目的一个例子是：
直到这座桥坍塌，工程师们才知道应该充分地考虑空气动力学的因素。只有通过建造大桥（即解决这个问题），他们才能学会从这一问题中应该额外考虑的环节，
从而才能建造出到现在依然矗立不倒的另一座桥梁；
|
想要通过一种理性的、不会犯错的方式从需求说明中推导出设计根本就不现实；
没有哪个系统是用这种方式设计出来的，以后也不可能有；即便是教科书和论文中的小型程序开发也是不真实的；
它们都是经过修订和修饰的，直到作者让我们看到他想要做到的结果，因而是不可能在实际中发生的过程；
 
设计是个了无章法的过程（即使它能得出清爽的成果）
|
因为在此过程中你会采取很多错误的步骤，你会犯很多的错误，事实上，犯错正是设计的关键所在；
还因为优、劣设计之间的差异往往非常微妙；
还因为你很难判断设计何时算是“足够好”了，一般最常见的回答是“到你没时间再做了为止”；
 
设计就是确定取舍和调整顺序的过程
|
衡量彼此冲突的各项设计特性（例如快速的反应速度，开发时间等），并尽力在其中寻求平衡；
 
设计受到诸多限制
|
这样才会促使产生简单的方案，并最终改善这一解决方案；
 
设计是不确定的
|
不同的人会有不同的设计，而每套设计都很不错；
 
设计是一个启发式过程
|
因为设计过程充满了不确定性，因此设计技术也就趋于具有探索性；
“经验法则”或者“试试没准能行的办法”，而不是保证能产生预期结果的可重复的过程；
 
设计是自然而然形成的
|
设计不是在谁的头脑中直接跳出来的；
它是在不断的设计评估、非正式讨论、写试验代码以及修改试验代码中演化和完善的；
 
软件并非是唯一会随时间变化而变化的结构。物理结构也会演变；
|
几乎所有的系统都在其开发的起始阶段经历过某种程度的设计变更，而当它们进入后续版本后通常都会进行更大的改变。
||
所以。。。就弄一个自己非常想做的一个小程序就行了，先不用管实现多复杂，先自由的天马行空的想自己想做的，抛开应用程序方面的（我觉得应用程序可能还是需要一个公司去运营）；
 
 
关键的设计概念
管理复杂度
|
偶然的难题和本质的难题
软件开发中大部分的偶然性难题在很久以前就得到解决了；
本质性苦难上的进展将会变得相对缓慢；
所有这些本质性困难的根源都在于复杂性——不论是本质的，还是偶然的；
|
人类心理：哈哈；
没有谁的大脑能容得下一个现代的计算机程序，
我们不应该试着在同一时间把整个程序都塞进自己的大脑，
而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。
|
这么做的目的是尽量减少在任一时间所要考虑的程序量；
可以把它想做是一种心理上的杂耍（边抛边接）——程序要求你在空中保持的（精神上的）球越多，你就越可能漏掉其中的某一个，从而导致设计或编码的错误；
|
在软件架构的层次上，
可以通过把整个系统分解为多个子系统来降低问题的复杂度；
|
人类心理：哈哈；
人类更易于理解许多项简单的信息，而不是一项复杂的信息；
子系统间的相互依赖越少，你就越容易在同一时间里专注问题的一小部分；
精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情；
|
人类心理：哈哈；
保持子程序的短小精悍也能帮助你减少思考的负担。
从问题的领域着手，而不是从底层实现的细节入手去编写程序，在最抽象的层次上工作，也能减少人的脑力负担；
|
人类心理：哈哈；
受着人类固有限制影响的程序员的底线，就是要写出既让自己容易理解，也能让别人容易看懂，而且很少有错误的程序代码；

如何应对复杂度
|
1，把任何人在同一时间需要处理的本质复杂度的量减到最少；
2，不要让偶然性的复杂度无谓的快速增长；

当我解决问题的时候，我从来不考虑美感；我只想着如何才能解决它。
但一旦解决了问题，如果解决方法不够优美的话，我就知道错了。

理想的设计特征
|
1，最小的复杂度：
专注于程序的一部分时安心地忽视其他部分；
2，松散耦合：
设计出相互关联尽可能最少的类；
3，高扇入：
让大量的类使用某个给定的类；
4，低扇出：
一个类里少量或适中地使用其他的类；
5，精简性：
不能再删去任何内容；
6，层次性：
举例来说，假设你正在编写一个新系统，其中用到很多设计不佳的旧代码，这时你就应该为新系统编写一个负责同旧代码交互的层。
在设计这一层时，要让它能隐藏旧代码的低劣质量，同时为新的层次提供一组一致的服务。
7，标准技术

设计的层次：
|
软件系统：
||
分解为子系统和包：
|||
确定如何把程序分为主要的子系统，并定义清楚允许个子系统如何使用其他子系统；
子系统间的相互通信规则：限制；
最简单的交互关系是让一个子系统去调用另一个子系统中的子程序；
稍微复杂一点的交互关系是让一个子系统中包含另一个子系统中的类；
而最复杂的交互关系是让一个子系统中的类继承另一个子系统中的类；
这次子系统可能会很大，比如：数据库、用户界面、业务规则、命令解释器、报表引擎等；
||
分解为包中的类：
|||
设计出系统中所有的类；尤其是定义好类的接口；
||
分解为类中的数据和子程序：
|||
定义出类内部的子程序——》常常会有助于更好的理解类的接口，反过来，这又有助于对类的接口进行进一步修改；
||
子程序内部：
|||
包括编写伪代码、选择算法、组织子程序内部的代码块以及用编程语言编写代码；


设计构造块：启发式方法
|
由于软件设计是非确定性的，因此，灵活熟练地运用一组有效的启发式方法（试探法），便成了合理的软件设计的核心工作；
以下部分会依据软件的首要技术使命——管理复杂度——的原则来讲解每一种启发式方法。
||
找出现实世界中的对象：
|||
辨识对象及其属性；
确定可以对各个对象进行的操作；——》在每个对象之上都可以执行多种操作；
确定各个对象能对其他对象进行的操作；——》对象之间最常见的两种关系是包含和继承；
确定对象的哪些部分对其它对象可见；——》包括数据和方法；
定义每个对象的接口；
综上：经过上述这些步骤得到了一个高层次的、面向对象的系统组织结构之后，你可以用这两种方法来迭代：
     在高层次的系统组织结构上进行迭代，以便更好地组织类的结构；或者在每一个已经定义好的类上进行迭代，把每个类的设计细化；
||
形成一致的抽象：
|||
聚合物品，例如房子、城镇；
优秀的程序员会在子程序接口的层次上、在类接口的层次上以及包接口的层次上——换句话说，
在门把手的层次上、门的层次上以及房屋的层次上——进行抽象，这样才能更快、更稳妥地进行开发；
||
封装实现细节：
|||
封装填补了抽象留下的空白；
抽象“可以让你从高层的细节来看待一个对象”；
封装“除此之外，你不能看到对象的任何其他细节层次”；
||
当继承能简化设计时就继承：
||
隐藏秘密（信息隐藏）：
|||
例子：一个程序其中的每个对象都是通过一个名为id的成员变量来保存一种唯一的ID，id = ++g_maxId;
核心：想想以后会改变的地方；
例如：如果你想把某些范围的ID留做它用该怎么办？如果你想使用非连续ID来提高安全性又该怎么办？
     如果你想重新使用已销毁对象的ID呢？等等。。。
创建新ID的方法就是一种你应该隐藏起来的设计决策；
可以使用：id = NewId()；——》就把创建新ID的方法隐藏起来了；
|||
信息隐藏的障碍；——》大多数让信息无法隐藏的障碍都是由于惯用某些技术而导致的心理障碍；
||||
信息过度分散——》你可能把100这个数字直接写到了程序里，这样会导致对它的引用过于分散，可以把它写入一个叫MAX_EMPLOYEES的常量中；
              另一个例子是在系统内部到处都是与人机交互相关的内容，一旦交互方式改变——比如说从图形界面变为命令行界面——那么几乎所有代码都需要改动；
              再举一个关于全局数据项的例子——比如说一个在程序全局范围内都可以访问的、含有1000个元素的员工数据数组，
                 如果程序直接使用该全局数据，就会在程序中到处分散；而如果通过访问器子程序来使用该数据的话，就只有访问器子程序才知道其实现细节了。
循环依赖——》A类中的子程序调用了B类中的子程序，B类中的子程序又调用了A类中的子程序；
把类内数据误认为全局数据
可以察觉的性能损耗——》试图在系统架构层和编码层均避免性能上的损耗，但你不必在任何一层去担心。
                   在架构层按照信息隐藏的目标去设计系统并不会与按照性能目标去设计相冲突；
                   在编码层能为性能目标所做的最好的准备，便是做出高度模块化的设计来，等日后找出性能的瓶颈，就可以针对个别的类或者子程序进行优化而不会影响系统的剩余部分了；
||
找出容易改变的区域：
||
保持松散耦合：
||



















































 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



