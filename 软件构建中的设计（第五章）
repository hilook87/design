设计是一项明确的活动

设计是一个险恶的问题
|
“险恶的”问题就是那种只有通过解决或部分解决才能被明确的问题；
最引人注目的一个例子是：
直到这座桥坍塌，工程师们才知道应该充分地考虑空气动力学的因素。只有通过建造大桥（即解决这个问题），他们才能学会从这一问题中应该额外考虑的环节，
从而才能建造出到现在依然矗立不倒的另一座桥梁；
|
想要通过一种理性的、不会犯错的方式从需求说明中推导出设计根本就不现实；
没有哪个系统是用这种方式设计出来的，以后也不可能有；即便是教科书和论文中的小型程序开发也是不真实的；
它们都是经过修订和修饰的，直到作者让我们看到他想要做到的结果，因而是不可能在实际中发生的过程；
 
设计是个了无章法的过程（即使它能得出清爽的成果）
|
因为在此过程中你会采取很多错误的步骤，你会犯很多的错误，事实上，犯错正是设计的关键所在；
还因为优、劣设计之间的差异往往非常微妙；
还因为你很难判断设计何时算是“足够好”了，一般最常见的回答是“到你没时间再做了为止”；
 
设计就是确定取舍和调整顺序的过程
|
衡量彼此冲突的各项设计特性（例如快速的反应速度，开发时间等），并尽力在其中寻求平衡；
 
设计受到诸多限制
|
这样才会促使产生简单的方案，并最终改善这一解决方案；
 
设计是不确定的
|
不同的人会有不同的设计，而每套设计都很不错；
 
设计是一个启发式过程
|
因为设计过程充满了不确定性，因此设计技术也就趋于具有探索性；
“经验法则”或者“试试没准能行的办法”，而不是保证能产生预期结果的可重复的过程；
 
设计是自然而然形成的
|
设计不是在谁的头脑中直接跳出来的；
它是在不断的设计评估、非正式讨论、写试验代码以及修改试验代码中演化和完善的；
 
软件并非是唯一会随时间变化而变化的结构。物理结构也会演变；
|
几乎所有的系统都在其开发的起始阶段经历过某种程度的设计变更，而当它们进入后续版本后通常都会进行更大的改变。
||
所以。。。就弄一个自己非常想做的一个小程序就行了，先不用管实现多复杂，先自由的天马行空的想自己想做的，抛开应用程序方面的（我觉得应用程序可能还是需要一个公司去运营）；
 
 
关键的设计概念
管理复杂度
|
偶然的难题和本质的难题
软件开发中大部分的偶然性难题在很久以前就得到解决了；
本质性苦难上的进展将会变得相对缓慢；
所有这些本质性困难的根源都在于复杂性——不论是本质的，还是偶然的；
|
人类心理：哈哈；
没有谁的大脑能容得下一个现代的计算机程序，
我们不应该试着在同一时间把整个程序都塞进自己的大脑，
而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。
|
这么做的目的是尽量减少在任一时间所要考虑的程序量；
可以把它想做是一种心理上的杂耍（边抛边接）——程序要求你在空中保持的（精神上的）球越多，你就越可能漏掉其中的某一个，从而导致设计或编码的错误；
|
在软件架构的层次上，
可以通过把整个系统分解为多个子系统来降低问题的复杂度；
|
人类心理：哈哈；
人类更易于理解许多项简单的信息，而不是一项复杂的信息；
子系统间的相互依赖越少，你就越容易在同一时间里专注问题的一小部分；
精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情；
|
人类心理：哈哈；
保持子程序的短小精悍也能帮助你减少思考的负担。
从问题的领域着手，而不是从底层实现的细节入手去编写程序，在最抽象的层次上工作，也能减少人的脑力负担；
|
人类心理：哈哈；
受着人类固有限制影响的程序员的底线，就是要写出既让自己容易理解，也能让别人容易看懂，而且很少有错误的程序代码；

如何应对复杂度
|
1，把任何人在同一时间需要处理的本质复杂度的量减到最少；
2，不要让偶然性的复杂度无谓的快速增长；

当我解决问题的时候，我从来不考虑美感；我只想着如何才能解决它。
但一旦解决了问题，如果解决方法不够优美的话，我就知道错了。

理想的设计特征
|
1，最小的复杂度：
专注于程序的一部分时安心地忽视其他部分；
2，松散耦合：
设计出相互关联尽可能最少的类；
3，高扇入：
让大量的类使用某个给定的类；
4，低扇出：
一个类里少量或适中地使用其他的类；
5，精简性：
不能再删去任何内容；
6，层次性：
举例来说，假设你正在编写一个新系统，其中用到很多设计不佳的旧代码，这时你就应该为新系统编写一个负责同旧代码交互的层。
在设计这一层时，要让它能隐藏旧代码的低劣质量，同时为新的层次提供一组一致的服务。
7，标准技术

设计的层次：
|
软件系统：
||
分解为子系统和包：
|||
确定如何把程序分为主要的子系统，并定义清楚允许个子系统如何使用其他子系统；
子系统间的相互通信规则：限制；
最简单的交互关系是让一个子系统去调用另一个子系统中的子程序；
稍微复杂一点的交互关系是让一个子系统中包含另一个子系统中的类；
而最复杂的交互关系是让一个子系统中的类继承另一个子系统中的类；
这次子系统可能会很大，比如：数据库、用户界面、业务规则、命令解释器、报表引擎等；
||
分解为包中的类：
|||
设计出系统中所有的类；尤其是定义好类的接口；
||
分解为类中的数据和子程序：
|||
定义出类内部的子程序——》常常会有助于更好的理解类的接口，反过来，这又有助于对类的接口进行进一步修改；
||
子程序内部：
|||
包括编写伪代码、选择算法、组织子程序内部的代码块以及用编程语言编写代码；


设计构造块：启发式方法
|
由于软件设计是非确定性的，因此，灵活熟练地运用一组有效的启发式方法（试探法），便成了合理的软件设计的核心工作；
以下部分会依据软件的首要技术使命——管理复杂度——的原则来讲解每一种启发式方法。
||
找出现实世界中的对象
||
形成一致的抽象
||
封装实现细节
||
当继承能简化设计时就继承
||
隐藏秘密（信息隐藏）
||
找出容易改变的区域
||
保持松散耦合
||



















































 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



